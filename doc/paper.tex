\documentclass[sigconf]{acmart}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{matrix}
\usetikzlibrary{graphs}
\usetikzlibrary{shapes.geometric}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18} % Recommended for modern TikZ/pgfplots
\usepackage{environ}
\usepackage{ifthen}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{fp}
\usepackage{makecell}
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

\setcopyright{acmlicensed}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{XXXXXXX.XXXXXXX}
%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[FPGA '26]{International Symposium on Field Programable Gate Arrays}{June 03--05,
  2025}{Seaside, CA}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}

\begin{document}

\title{Multi-Port Memory with Bi-directional Ports for FPGAs Using XOR and LVT Methods}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%\author{Kevin Townsend}
\author{XXX}
\email{XXX@XXX}

%\renewcommand{\shortauthors}{Townsend}
\renewcommand{\shortauthors}{XXX}

\begin{abstract}
  We propose a simple extention to XOR memories presented in previous work.
In this paper we generalize the XOR memory allowing for any number of full, read-only and write-only ports.
This paper also presents a novel and efficient architecture for creating live value table memory using an XOR-based scheme, emphasizing its bidirectional capabilities.

This is achieved by exploiting the properties of XOR, allowing any data entry to be reconstructed by XORing the corresponding entries from all memory banks. The result is a high-throughput, coherent multi-ported memory that is particularly well-suited for implementation on FPGAs.

We use an XOR memory with full ports to implement a live value table (LVT) design.
We evaluate the architecture's performance and resource utilization, showing that it uses significantly less logic and can achieve higher frequencies for deep memory configurations compared to LVT-based designs. This makes the XOR-based bidirectional live value table a compelling alternative for applications requiring high-performance, flexible memory access.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%\begin{CCSXML}
%<ccs2012>
% <concept>
%  <concept_id>00000000.0000000.0000000</concept_id>
%  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%  <concept_significance>500</concept_significance>
% </concept>
% <concept>
%  <concept_id>00000000.00000000.00000000</concept_id>
%  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%  <concept_significance>300</concept_significance>
% </concept>
% <concept>
%  <concept_id>00000000.00000000.00000000</concept_id>
%  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%  <concept_significance>100</concept_significance>
% </concept>
% <concept>
%  <concept_id>00000000.00000000.00000000</concept_id>
%  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%  <concept_significance>100</concept_significance>
% </concept>
%</ccs2012>
%\end{CCSXML}
%
%\ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%\ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%\ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%\ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
%\keywords{Do, Not, Us, This, Code, Put, the, Correct, Terms, for,
%  Your, Paper}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.

\received{1 Octomber 2025}
\received[revised]{XX XXX XXXX}
\received[accepted]{XX XXX XXXX}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Motivation}

\begin{figure*}
  %\includegraphics[width=\textwidth]{sampleteaser}
  \centering
  %\begin{center}
  %\begin{scaletikzpicturetowidth}{\textwidth}
  \begin{tikzpicture}[scale=1.3]
  \foreach \x in {0,1,2,3,4,5} {
    \foreach \y in {0,1,2,3} {
      \ifthenelse{\(\x = 2 \AND \y = 1\) \OR \(\x = 3 \AND \y = 0\)}{}{
        \node (r\x\y)[trapezium, trapezium left angle=70, trapezium right angle=110, draw] at (2*\x, \y){RAM$_{\x,\y}$};
      }
    }
  }
  \foreach \x in {0,1,4,5} {
    \node (bport\x)[] at (2*\x+1, -1){PORT\x};
  }
  \foreach \y in {0,1,2,3} {
    \node (lport\y)[] at (-1.3, 3.5-\y){PORT\y};
  }
  %TODO: fix connections
  \node [rotate=90] at (-2, .8){WRITE PORTS};
  \node [rotate=90] at (-2, 2.8){FULL PORTS};
  \node [] at (1.5, -1.5){FULL PORTS};
  \node [] at (9.5, -1.5){READ PORTS};
  \node(x50)[inner sep=0pt] at (10.8, 0){$\oplus$};
  \node(x51)[inner sep=0pt] at (10.8, 1){$\oplus$};
  \node(x52)[inner sep=0pt] at (10.8, 2){$\oplus$};
  \draw[->] (r50) -- (x50);
  \draw[->] (r51) -- (x51);
  \draw[->] (r52) -- (x52);
  \draw[->] (r53) -| (x52);
  \draw[->] (x52) -- (x51);
  \draw[->] (x51) -- (x50);
  \draw[->] (x50) -- (bport5.130);
  \node(x40)[inner sep=0pt] at (8.8, 0){$\oplus$};
  \node(x41)[inner sep=0pt] at (8.8, 1){$\oplus$};
  \node(x42)[inner sep=0pt] at (8.8, 2){$\oplus$};
  \draw[->] (r40) -- (x40);
  \draw[->] (r41) -- (x41);
  \draw[->] (r42) -- (x42);
  \draw[->] (r43) -| (x42);
  \draw[->] (x42) -- (x41);
  \draw[->] (x41) -- (x40);
  \draw[->] (x40) -- (bport4.130);
  \node(x31)[inner sep=0pt] at (6.8, 1){$\oplus$};
  \node(x32)[inner sep=0pt] at (6.8, 2){$\oplus$};
  \node(x30)[inner sep=0pt] at (6.8, .5){$\oplus$};
  \draw[->] (r31) -- (x31);
  \draw[->] (r32) -- (x32);
  \draw[->] (r33) -| (x32);
  \draw[->] (x32) -- (x31);
  \draw[->] (x31) -- (x30);
  %PORT3 connections.
  \draw[->] (lport3) -- (x30);
  \draw[->] (x30) |- (-.6,.3) |- (r00);
  \draw[->] (1.4,.3) |- (r10);
  \draw[->] (3.4,.3) |- (r20);
  \draw[->] (6.8, .3) -| (7.4,0) -- (r40);
  \draw[->] (7.4, .3) -| (9.4,0) -- (r50);
  %PORT2 XORs
  \node(x22)[inner sep=0pt] at (4.8, 2){$\oplus$};
  \node(x21)[inner sep=0pt] at (4.8, 1.5){$\oplus$};
  %PORT2 connections
  \draw[->] (lport2) -- (x21);
  \draw[->] (r23) -| (x22);
  \draw[->] (r22) -- (x22);
  \draw[->] (x22) -- (x21);
  \draw[->] (r20) -| (x21);
  \draw[->] (x21) -| (5,1.3) -| (-.6,1) -- (r01);
  \draw[->] (1.4,1.3) |- (r11);
  \draw[->] (5,1.3) -- (9.4, 1.3) |- (r51);
  \draw[->] (7.4, 1.3) |- (r41);
  \draw[->] (5.4, 1.3) |- (r31);
  %draw xor of full ports
  %PORT1
  \node(x11)[inner sep=0pt] at (2.8, 1){$\oplus$};
  \node(x12)[inner sep=0pt] at (3.3, 2.5){$\oplus$};
  \node(x12b)[inner sep=0pt] at (3, 2){$\oplus$};
  \node(x13)[inner sep=0pt] at (2.8, 3){$\oplus$};
  \draw[->] (r10) -| (x11);
  \draw[->] (r11) -- (x11);
  \draw[->] (lport1) -- (x12);
  \draw[->] (x11) -- (x13);
  \draw[->] (r13) -- (x13);
  \draw[->] (x13) -| (x12);
  \draw[->] (r12) -- (x12b);
  \draw[->] (x12) -| (3.3, 2.3) -| (-.6,2) -- (r02);
  \draw[->] (1.4,2.3) |- (r12);
  \draw[->] (3.3, 2.3) -- (9.4, 2.3) |- (r52);
  \draw[->] (3.4, 2.3) |- (r22);
  \draw[->] (5.4, 2.3) |- (r32);
  \draw[->] (7.4, 2.3) |- (r42);
  \draw[->] (x13) -| (x12b);
  \draw[->] (x12b) -- (bport1);
  %PORT0
  \node(x01)[inner sep=0pt] at (0.8, 1){$\oplus$};
  \node(x02)[inner sep=0pt] at (0.8, 2){$\oplus$};
  \node(x03)[inner sep=0pt] at (0.8, 3.5){$\oplus$};
  \node(x03b)[inner sep=0pt] at (1.0, 2.8){$\oplus$};
  \draw[->] (r00) -| (x01);
  \draw[->] (r01) -- (x01);
  \draw[->] (x01) -- (x02);
  \draw[->] (x02) -- (x03);
  \draw[->] (lport0) -- (x03);
  \draw[->] (x03) -| (1, 3.3) -| (-.6,3) -- (r03);
  \draw[->] (1, 3.3) -- (9.4, 3.3) |- (r53);
  \draw[->] (1.4, 3.3) |- (r13);
  \draw[->] (3.4, 3.3) |- (r23);
  \draw[->] (5.4, 3.3) |- (r33);
  \draw[->] (7.4, 3.3) |- (r43);
  \draw[->] (.8, 2.8) -- (x03b);
  \draw[->] (r02) -- (x02);
  \draw[->] (r03) -| (x03b);
  \draw[->] (x03b) -- (bport0);
  \end{tikzpicture}
  %\end{scaletikzpicturetowidth}
  %\end{center}
  \caption{A multi-port memory with 2 full ports, 2 write-only ports and 2 read-only ports.}
  \Description{Enjoying the baseball game from the third-base
  seats. Ichiro Suzuki preparing to bat.}
  \label{fig:teaser}
\end{figure*}
\begin{figure}
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \begin{tikzpicture}[scale=3]
      \draw (.25,1.75) rectangle (.75,2.25);
      \foreach \j in {-.15,-.05, .05, .15}{
          \draw[] (.25, 2+\j) -- (.75,2+\j);
      }
      \foreach \i/\v in {0/1101,1/1111,2/0111,3/1000,4/0101}{
          \FPeval{\x}{.7-\i*.1};
          \FPeval{\y}{2-.2+\i*.1};
          \node[] at (.5,\y) {\v};
      }
      \node at (.5,2.25)[anchor=south]{RAM$_{emulated}$};
      \draw[xshift=-.5cm] (.25,0.75) rectangle (.75,1.25);
      \node at (0,1.25) [anchor=south]{RAM$_{0,0}$};
      \foreach \j in {-.15,-.05, .05, .15}{
          \draw[] (-.25, 1+\j) -- (.25,1+\j);
      }
      \foreach \i/\v in {0/1010,1/1111,2/0100,3/1010,4/0100}{
          \FPeval{\x}{.7-\i*.1};
          \FPeval{\y}{1-.2+\i*.1};
          \node[] at (0,\y) {\v};
      }
      \draw[xshift=.5cm] (.25,0.75) rectangle (.75,1.25);
      \node at (1,1.25) [anchor=south]{RAM$_{1,0}$};
      \foreach \j in {-.15,-.05, .05, .15}{
          \draw[] (1-.25, 1+\j) -- (1.25,1+\j);
      }
      \foreach \i/\v in {0/1010,1/1111,2/0100,3/1010,4/0100}{
          \FPeval{\y}{1-.2+\i*.1};
          \node[] at (1,\y) {\v};
      }
      \draw[xshift=-.5cm,yshift=-1cm] (.25,0.75) rectangle (.75,1.25);
      \node at (0,.25) [anchor=south]{RAM$_{0,1}$};
      \foreach \j in {-.15,-.05, .05, .15}{
          \draw[] (0-.25, 0+\j) -- (0.25,0+\j);
      }
      \foreach \i/\v in {0/0111,1/0000,2/0011,3/0010,4/0001}{
          \FPeval{\y}{1-.2+\i*.1};
          \node[] at (0,-1+\y) {\v};
      }
      \draw[xshift=.5cm,yshift=-1cm] (.25,0.75) rectangle (.75,1.25);
      \node at (1,.25) [anchor=south]{RAM$_{1,1}$};
      \foreach \j in {-.15,-.05, .05, .15}{
          \draw[] (1-.25, 0+\j) -- (1.25,0+\j);
      }
      \foreach \i/\v in {0/0111,1/0000,2/0011,3/0010,4/0001}{
          \FPeval{\y}{1-.2+\i*.1};
          \node[] at (1,-1+\y) {\v};
      }
      %draw XORs
      \node(x0)[inner sep=0pt] at (.5,0){$\oplus$};
      \node(x1)[inner sep=0pt] at (1.5,.5){$\oplus$};
      %draw ports
      \node(p0) at (.5,-.5) {PORT0};
      \node(p1) at (-.5,.5) [rotate=90]{PORT1};
      %draw connections
      \draw[->] (p1) -- (x1) node[pos=.75,fill=white]{1000};
      \draw[->] (1.25,1) -| (x1);
      \draw (x1) |- (-.3, .45);
      \draw[->] (-.3, .45) |- (-.25, 0);
      \draw[->] (.65, .45) |- (.75, 0);
      \draw[->] (.25, 1) -| (x0);
      \draw[->] (.25, 0) -- (x0);
      \draw[->] (x0) -- (p0);
      %TODO: draw emulated ram connections.
      \node(ep1) at (-.5,2) {PORT1};
      \draw[->] (ep1) -- (.25,2) node[midway,fill=white]{1000};
      \node(ep0) at (1.25,2) {PORT0};
      \draw[->] (.75,2) -- (ep0);
    \end{tikzpicture}
    \caption{Clock cycle 0.}

  \end{subfigure}
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \begin{tikzpicture}[scale=3]
      %draw emulated ram
      %\draw[] (.5,2-.25) -- (1,2-.25) -- (.5,2.25) -- (0, 2.25) -- cycle;
      \draw (.25,1.75) rectangle (.75,2.25);
      \foreach \j in {-.15,-.05, .05, .15}{
          \draw[] (.25, 2+\j) -- (.75,2+\j);
      }
      \foreach \i/\v in {0/1101,1/1111,2/1000,3/1000,4/0101}{
          \FPeval{\x}{.7-\i*.1};
          \FPeval{\y}{2-.2+\i*.1};
          \node[] at (.5,\y) {\v};
      }
      \node at (.5,2.25)[anchor=south]{RAM$_{emulated}$};
      \draw[xshift=-.5cm] (.25,0.75) rectangle (.75,1.25);
      \node at (0,1.25) [anchor=south]{RAM$_{0,0}$};
      \foreach \j in {-.15,-.05, .05, .15}{
          \draw[] (-.25, 1+\j) -- (.25,1+\j);
      }
      \foreach \i/\v in {0/1010,1/1111,2/0100,3/1010,4/0100}{
          \FPeval{\x}{.7-\i*.1};
          \FPeval{\y}{1-.2+\i*.1};
          \node[] at (0,\y) {\v};
      }
      \draw[xshift=.5cm] (.25,0.75) rectangle (.75,1.25);
      \node at (1,1.25) [anchor=south]{RAM$_{1,0}$};
      \foreach \j in {-.15,-.05, .05, .15}{
          \draw[] (1-.25, 1+\j) -- (1.25,1+\j);
      }
      \foreach \i/\v in {0/1010,1/1111,2/0100,3/1010,4/0100}{
          \FPeval{\y}{1-.2+\i*.1};
          \node[] at (1,\y) {\v};
      }
      \draw[xshift=-.5cm,yshift=-1cm] (.25,0.75) rectangle (.75,1.25);
      \node at (0,.25) [anchor=south]{RAM$_{0,1}$};
      \foreach \j in {-.15,-.05, .05, .15}{
          \draw[] (0-.25, 0+\j) -- (0.25,0+\j);
      }
      \foreach \i/\v in {0/0111,1/0000,2/1100,3/0010,4/0001}{
          \FPeval{\y}{1-.2+\i*.1};
          \node[] at (0,-1+\y) {\v};
      }
      \draw[xshift=.5cm,yshift=-1cm] (.25,0.75) rectangle (.75,1.25);
      \node at (1,.25) [anchor=south]{RAM$_{1,1}$};
      \foreach \j in {-.15,-.05, .05, .15}{
          \draw[] (1-.25, 0+\j) -- (1.25,0+\j);
      }
      \foreach \i/\v in {0/0111,1/0000,2/1100,3/0010,4/0001}{
          \FPeval{\y}{1-.2+\i*.1};
          \node[] at (1,-1+\y) {\v};
      }
      %TODO: add ports
      \node(p0) at (.5,-.5) {PORT0};
      %TODO: add xors
      \node(x0)[inner sep=0pt] at (.5,0){$\oplus$};
      %TODO: add connections
      \draw[->] (.25, 1) -| (x0);
      \draw[->] (.25, 0) -- (x0);
      \draw[->] (x0) -- (p0);
      %TODO: add ports
      \node(p1) at (1.5,-.5) {PORT1};
      %TODO: add xors
      \node(x1)[inner sep=0pt] at (1.5,0){$\oplus$};
      %TODO: add connections
      \draw[->] (1.25, 1) -| (x1);
      \draw[->] (1.25, 0) -- (x1);
      \draw[->] (x1) -- (p1);
      %TODO: add emulated ports
      \node(ep0) at (1.25, 2.1) {PORT0};
      \node(ep1) at (1.25, 1.9) {PORT1};
      \draw (.75,2) -- (.9,2);
      \draw[->] (.9,2) |- (ep0);
      \draw[->] (.9,2) |- (ep1);
    \end{tikzpicture}
    \caption{Clock cycle 1.}
  \end{subfigure}
  \caption{XOR Multi-port memory.}
  \label{fig:xor_example}
  \Description{An illustration.}
\end{figure}


As computation needs keep increasing, one way to keep up has been
specialized architectures. FPGAs provide a way to implement architectures without taping out an ASIC.
However, the limitations of FPGA resources means some creativity is needed to map designs to FPGAs.
This paper explores the limitation of FPGAs in the fact that FPGA memories have a limited number of
ports. Specifically we look at creating memories with more than 2 ports.

The major FPGA vendors (AMD\cite{amd20}, Intel\cite{intel24}, Lattice\cite{lattice21}, Micro\-chip\cite{microchip_polarfire_fabric}, Achronix\cite{achronix_ds015}) implement distributed memory (small memories) and block memory (large memories)
differently, however they share some characteristics. All vendors support distributed memory configurations with 1 full or write port and between 1 to 3 read ports. All vendors support block memory with 2 full ports. None of the vendors support memories with more than 2 full ports. Although this limitation is problematic for designs requiring multiple ports particularly write or full ports, we show that these resources make it possible to achieve high throughput quad and octal full port memories.

\section{Source Code}
We provide all of the source code used in implementation and testing our design at
https://anonymous.4open.science/r/mpm-7666/. We tested our design with Verilator\cite{verilator_manual} and synthesized the design
with Vivado\cite{ug893}.

\section{Related Work}

%TODO: add citations
Several solutions to the port limit on FPGAs other than what is presented here.
For example multi-pumping and banking. multi-pumping is the process of reducing
the clock speed to increase the number of ports. For example a 300Mhz single
port memory can handle two 150Mhz ports. Banking requires stalls and routing logic
due to the segmented memory. Our design is most similar to replication. Replication involves tying the write ports of multiple memories together to create additional read ports.

\section{XOR memory}

%TODO: move up to page 1.
%TODO: add figure with 2 subfigures
We propose a simple generalization to XOR memories presented in previous work\cite{laforest14}.
XOR memories work by using the following property:
\begin{equation}
a \oplus b \oplus b = a
\end{equation}
We add bidirectional
ports and analyze the perforamance of distributed memory and block memory
versions of this design. We also present applications for these memories.

The number of RAMs needed is:
\begin{equation}
(W+F)(W+F+R)-W
\end{equation}
Which expands to:
\begin{equation}
W^2 + 2WF + F^2 + WR + FR - W
\end{equation}
Where $W$ is the number of write ports, $R$ is the number of read ports and $F$ is the number of full ports. Figure \ref{fig:teaser} shows an XOR memory with 2 read ports, 2 write ports and 2 full ports, resulting in 22 RAMs.

Reading data from an XOR memory simply involves XORing all of the data from the RAMs in one column from the same address. For example, say address $x$ has values $A$, $B$, $C$ and $D$, the data read would be $A\oplus B\oplus C \oplus D$.

Writing to the memory involves reading from all memories except the current row (say row/port 2 in figure \ref{fig:teaser}) and XORing the incoming data $E$ (in the example this results in $A\oplus B \oplus D \oplus E$) and storing that value in all the RAMs in that row.

The next time that data is read the result will be $A\oplus B \oplus (A \oplus B\oplus D\oplus E) \oplus D$, which equals $E$.

You may notice that writing to a port involves XORing all but one stored value and reading involves XORing all values. This enables full ports to be created just by adding one RAM to what would otherwise be just a write port.

Note that this memory requires that all of the RAMs in a row have the same data. Initializing the rams to the same data (e.g. all 0s) is required for the memory to operate properly. This is not an issue in FPGAs since the memory can be initialized to 0. since rows are written to at the same time as long as the memories are intially the same they will remain the same.

We provide a second example with figure \ref{fig:xor_example} showing a clock cycle of an XOR memory with 2 full ports.

\section{Analysis of XOR memory}

We analyze several configurations of XOR memories. Particularly we vary the number of ports and width of the memory.

TODO: Analysis of varying the ports.
Table \ref{tab:syn_xor_ports} we show the varying resources and frequency of the memory for different numbers of ports. As seen the number of LUTs used for memory is relatively large particularly for more ports.

TODO: Analysis of varying the width.
In table \ref{tab:syn_xor_width}

TODO: Analysis with pipelining.
In table \ref{tab:syn_xor_bram_ports} we show an implementation using Block RAMs. This required pipelining and introducing a cycle of write delay. One could change the block ram to be write before read to remove the cycle of write delay.




\begin{table}
  \caption{Synthesis results of XOR memory for different port counts. The memory has a depth of 1024 and width of 32bits.}
  \label{tab:syn_xor_ports}
  \begin{tabular}{llllll}
    \toprule
    Ports & LUTS & \thead{LUTS\\ configured\\ as memory} & FF & BRAM & Max Frequency\\
    \midrule
    2 & 1,492 & 1,216 & 0 & 0 & 370Mhz\\
    4 & 6,312 & 5,248 & 0 & 0 & 317Mhz\\
    8 & 26,576 & 21,760 & 0 & 0 & 241Mhz\\
    16\footnotemark[1] & 107,424 & 88,576 & 0 & 0 & XMhz\\
    32\footnotemark[2] & 435,008 & 357,376 & 0 & 0 & N/A\\
    \bottomrule
  \end{tabular}
\end{table}

\begin{table}
  \caption{Synthesis results of XOR memory with block RAMs for different port counts}
  \label{tab:syn_xor_bram_ports}
  \begin{tabular}{llllll}
    \toprule
    Ports & LUTS & \thead{LUTS\\ configured\\ as memory} & FF & BRAM & Max Frequency\\
    \midrule
    2 & 128 & 0 & 150 & 4 & 278Mhz\\
    4 & 256 & 0 & 300 & 16 & 269Mhz\\
    8 & 768 & 0 & 600 & 64 & 197Mhz\\
    16\footnotemark[1] & 3,072 & 0 & 1,200 & 256 & XMhz\\
    32\footnotemark[1] & 10,240 & 0 & 2,400 & 1024 & XMhz\\
    \bottomrule
  \end{tabular}
\end{table}

\begin{table}
  \caption{Synthesis results of XOR memory for different widths}
  \label{tab:syn_xor_width}
  \begin{tabular}{llllll}
    \toprule
    Width & LUTS & \thead{LUTS\\ configured\\ as memory} & FF & BRAM & Max Frequency\\
    \midrule
    1 & 1,096 & 960 & 0 & 0 & XMhz\\
    2 & 2,144 & 1,920 & 0 & 0 & 290Mhz\\
    4 & 3,616 & 2,944 & 0 & 0 & 260Mhz\\
    8 & 7,152 & 5,888 & 0 & 0 & 235Mhz\\
    16 & 13,328 & 10,880 & 0 & 0 & 227Mhz\\
    32 & 26,576 & 21,760 & 0 & 0 & 217Mhz\\
    \bottomrule
  \end{tabular}
\end{table}

\section{Live Value Table Memory}
\begin{figure}
  \begin{tikzpicture}[xscale=2]
  %draw rams
  \foreach \x in {0,1,2,3} {
    \foreach \y in {0,1,2,3} {
      %TODO: add subscripts.
      \ifthenelse{\x < \y}{
      \node(r\y\x)[trapezium, trapezium left angle=70, trapezium right angle=110, draw] at (\x,3-\y) {RAM$_{\x,\y}$};
      }{
      \node[text=gray,dashed, trapezium, trapezium left angle=70, trapezium right angle=110, draw] at (\x,3-\y) {RAM$_{\x,\y}$};
      }
    }
  }
  %draw a ports
  \foreach \x in {0,1,2,3} {
    %\node(xport\x) at (\x, -1) {\x};
  }
  %draw b ports
  \foreach \y in {0,1,2,3} {
    %\node(yport\y) at (-1, 3-\y) {\y};
  }
  %draw connections
  %TODO: fix connections.
  \draw[<->] (r10.east) -| (.6,-.6) -| (.1,-1);
  \draw[->] (.2,-.6) -- (.2,-1);
  \draw[<->] (r20.east) -| (.5,-.5) -| (.0,-1);
  \draw[<->] (r30.east) -| (.4,-.4) -| (-.1,-1);
  \draw[<->] (r10) |- (1.6, 2.4) |- (1.2, -.6) -- (1.2,-1);
  \draw[->] (1.2,-.6) -| (1.1,-1);
  \draw[<->] (r21) -| (1.5,-.5) -| (1,-1);
  \draw[<->] (r31) -| (1.4,-.4) -| (.9,-1);
  \draw[<->] (r20) |- (2.5,1.5) |- (2.2, -.6) -- (2.2,-1);
  \draw[<->] (r21) |- (2.4,1.4) |- (2.1, -.5) -- (2.1,-1);
  \draw[->] (2.1,-.6) -| (2.0,-1);
  \draw[<->] (r32) -| (2.4,-.4) -| (1.9,-1);
  \draw[<->] (r30) |- (3.2,.6) -- (3.2,-1);
  \draw[<->] (r31) |- (3.1,.5) -- (3.1,-1);
  \draw[<->] (r32) |- (3.0,.4) -- (3.0,-1);
  \draw[->] (3.0,-.6) -| (2.9,-1);
%  %x0 connections
%  \draw (xport0) .. controls (.8,-1) and (.8,2) .. (r10.east);
%  \draw (xport0) .. controls (.6,-1) and (.7,1) .. (r20.east);
%  \draw (xport0) .. controls (.4,-1) and (.6,0) .. (r30.east);
%  %x1 connections
%  \draw (xport1) .. controls (1.6,-1) and (1.7,1) .. (r21);
%  \draw (xport1) .. controls (1.4,-1) and (1.6,0) .. (r31);
%  %x2 connection
%  \draw (xport2) .. controls (2.4,-1) and (2.6,0) .. (r32);
%  %y1 connection
%  \draw (yport1) .. controls (-1, 2.5) and (0, 2.5) .. (r10);
%  %y2 connections
%  \draw (yport2) .. controls (-1, 1.4) and (0, 1.4) .. (r20);
%  \draw (yport2) .. controls (-1, 1.6) and (1, 1.6) .. (r21);
%  %y3 connections
%  \draw (yport3) .. controls (-1, 0.4) and (0, 0.4) .. (r30);
%  \draw (yport3) .. controls (-1, 0.6) and (1, 0.6) .. (r31);
%  \draw (yport3) .. controls (-1, 0.8) and (2, 0.8) .. (r32);
%  %draw labels
%  \node at (-1.5, 1)[rotate=90]{Ports};
%  \node at (1, -1.5){Ports};
  %draw muxes
  \draw[xshift=-.2cm,yshift=-1cm] (0,0) -- (.1,-.2) -- (.4,-.2) -- (.5,0) -- cycle;
  \draw[xshift=.8cm,yshift=-1cm] (0,0) -- (.1,-.2) -- (.4,-.2) -- (.5,0) -- cycle;
  \draw[xshift=1.8cm,yshift=-1cm] (0,0) -- (.1,-.2) -- (.4,-.2) -- (.5,0) -- cycle;
  \draw[xshift=2.8cm,yshift=-1cm] (0,0) -- (.1,-.2) -- (.4,-.2) -- (.5,0) -- cycle;
  %draw LVT
  \node(lvt)[draw] at (1.5, -2) {LVT};
  %draw LVT connections
  \draw[->] (lvt) -- (.5,-2) |- (.25,-1.1);
  \draw[->] (lvt.100) |- (1.25,-1.1);
  \draw[->] (lvt.80) |- (1.85,-1.1);
  \draw[->] (lvt) -- (2.5,-2) |- (2.85,-1.1);
  %TODO: draw ports
  \draw[<->] (.05,-1.2) -- (.05,-1.6) node[right,midway]{0};
  \draw[<->] (1.05,-1.2) -- (1.05,-1.6) node[right,midway]{1};
  \draw[<->] (2.05,-1.2) -- (2.05,-1.6) node[right,midway]{2};
  \draw[<->] (3.05,-1.2) -- (3.05,-1.6) node[right,midway]{3};
  \end{tikzpicture}
 \caption{Multi-port memory created with bi-directional dual-port memories. Note, a live value table is needed to determine which memory has the most recent value.}
  \label{fig:lvt0}
  \Description{An illustration.}
\end{figure}

%\begin{figure}
%  \begin{tikzpicture}[yscale=1.2]
%    \node(lvt)[draw] at (2.5, 1) {LVT};
%    \foreach \x in {0,1,2,3}{
%    \node(mux\x)[draw,trapezium, rotate=-90,inner sep=5pt] at (2*\x,0){};
%    \node(mux\x port0) at (2*\x-.7,.3){0};
%    \node(mux\x port1) at (2*\x-.7,.1){1};
%    \node(mux\x port2) at (2*\x-.7,-.1){2};
%    \node(mux\x port3) at (2*\x-.7,-.3){3};
%    \ifthenelse{\x=0}{
%    \draw[->,dashed] (mux\x port0) -- (mux\x.210);
%    }{
%    \draw[->] (mux\x port0) -- (mux\x.210);
%    }
%    \ifthenelse{\x=1}{
%    \draw[->,dashed] (mux\x port1) -- (mux\x.240);
%    }{
%    \draw[->] (mux\x port1) -- (mux\x.240);
%    }
%    \ifthenelse{\x=2}{
%    \draw[->,dashed] (mux\x port2) -- (mux\x.300);
%    }{
%    \draw[->] (mux\x port2) -- (mux\x.300);
%    }
%    \ifthenelse{\x=3}{
%    \draw[->,dashed] (mux\x port3) -- (mux\x.330);
%    }{
%    \draw[->] (mux\x port3) -- (mux\x.330);
%    }
%    \draw[->] (mux\x ) -- (2*\x+.5,0);
%    \node at (2*\x,-.5) {PORT\x};
%    }
%    \draw[->] (lvt) .. controls (0,.5) .. (mux0);
%    \draw[->] (lvt) .. controls (2,.5) .. (mux1);
%    \draw[->] (lvt) .. controls (4,.5) .. (mux2);
%    \draw[->] (lvt) .. controls (6,.5) .. (mux3);
%  \end{tikzpicture}
%  \caption{The live value table for the memory in figure \ref{fig:lvt0}.}
%  \Description{An illustration.}
%\end{figure}

XOR memories can be used by themselves, however a live value table (LVT) may be more efficient.

We present a LVT memory that utilises distrubuted memory xor live value table.

In \cite{laforest12} the live value table was implemented with registers. Previous work used
distributed memory \cite{abdelhadi16}. However they did not use bidirectional xor ports in their implementation.

We create a LVT memory using the technique described in \cite{choi12}. This live value memory is composed of 2-(full)port memories. Each port shares a RAM with another port. This results in $N(N-1)/2$ RAMs being needed. See figure \ref{fig:lvt0}.

The memory gets its name because of a multi-port memory that tracks the most recent stored value (aka a live value table). The point of a multi-port memory that requires a multi-port memory is that wide (e.g. 32 bit data) can be stored more effeciently this way.

Instead of using a register based live-value table as in \cite{choi12} we use a xor memory similar to \cite{abdelhadi16}.

We show we utilize x\% less resources than LVT and I-LVT.

\section{Analysis of LVT Memory}

We explore LVT designs with 2 to 32 ports. Although 16 and 32 port designs fit on large FPGAs, we believe smaller 4 and 8 port designs are more practical. We say
more practical because of the high resource usage of XOR and LVT memories at high port counts.
N**2 for XOR and N*(N-1)/2 for LVT. However we were able to synthesize a 32 port memory.

Without write delay an 8 port memory runs at Xmhz (x\% of max). With write delay and pipelining the design runs at Xmhz (x\% of max).

%TODO: reference tables and figures.

\begin{figure}
  \begin{tikzpicture}
    \draw[->] (0,0) -- (4.5, 0);
    \draw (0,.1) -- (0, -.1) node[anchor=north] {2};
    \draw (1,.1) -- (1, -.1) node[anchor=north] {4};
    \draw (2,.1) -- (2, -.1) node[anchor=north] {8};
    \draw (3,.1) -- (3, -.1) node[anchor=north] {16\footnotemark[1]};
    \draw (4,.1) -- (4, -.1) node[anchor=north] {32\footnotemark[1]};
    %draw y axis
    \draw[->] (0,0) -- (0, 5.5);
    \draw (1pt, 0) -- (-1pt, 0) node[rotate=45,anchor=south east] {0Mhz};
    \foreach \y in {1,2,3,4,5}
      \draw (1pt, \y) -- (-1pt, \y) node[rotate=45,anchor=south east] {\y00Mhz};
    %labels
    \node at (2,-1) {PORTS};
    \node at (-1.5,2) [rotate=90]{FREQUENCY};
    %max frequncy
    \draw[dashed] (0, 5.44) -- (4, 5.44) node[anchor=west] {544Mhz};
    %line graphs
    \draw (0, 4.55) -- (1, 3.64) -- (2, 2.78) -- (3, 1.46) -- (4, 0.67);
    \node[fill=blue, draw,label={[rotate=30]right:455Mhz}] at (0,4.55){};
    \node[fill=blue, draw,label={[rotate=30]right:364Mhz}] at (1,3.64){};
    \node[fill=blue, draw,label={[rotate=30]right:278Mhz}] at (2,2.78){};
    \node[fill=blue, draw,label={[rotate=30]right:146Mhz}] at (3,1.46){};
    \node[fill=blue, draw,label={[rotate=30]right:67Mhz}] at (4,.67){};
    %line graph for pipelnined.
    \draw (0, 4.76) -- (1, 5.00) -- (2, 4.51) -- (3, 2.84);
    \node[fill=red, draw, circle,inner sep=2pt,label={[rotate=30]right:476Mhz}] at (0,4.76){};
  \end{tikzpicture}
  \caption{Frequency of design.}
  \Description{A graph showing the frequency of the design for difference port counts.}
\end{figure}

\footnotetext{To reduce the number of IO ports and fit the design on the FPGA we used a wrapper for the multi-port memory for designs with 16 and 32 ports.}

\begin{table}
  \caption{Synthesis results for different port counts}
  \label{tab:syn}
  \begin{tabular}{llllll}
    \toprule
    Ports & LUTS & \thead{LUTS\\ configured\\ as memory} & FF & BRAM & Max Frequency\\
    \midrule
    2 & 127 & X & 0 & 1 & 455Mhz\\
    4 & 640 & X & 0 & 6 & 364Mhz\\
    8 & 3,012 & X & 0 & 28 & 278Mhz\\
    16\footnotemark[1] & 16,544 & X & 0 & 120 & 146Mhz\\
    32\footnotemark[1] & 85,728 & X & 0 & 496 & 67Mhz\\
    \bottomrule
  \end{tabular}
\end{table}

\begin{table}
  \caption{Synthesis results for different port counts for pipelined design}
  \label{tab:synpiped}
  \begin{tabular}{llllll}
    \toprule
    Ports & LUTS & \thead{LUTS\\ configured\\ as memory} & FF & BRAM & Max Frequency\\
    \midrule
    2 & 111 & X & 26 & 1 & 476Mhz\\
    4 & 708 & X & 64 & 6 & 500Mhz\\
    8 & 3,092 & X & 152 & 28 & 451Mhz\\
    16\footnotemark[1] & 16,800 & X & 448 & 120 & 284Mhz\\
    32\footnotemark[1] & 86,608 & X & 1,502 & 496 & XMhz\\
    \bottomrule
  \end{tabular}
\end{table}
\section{Conclusion}
XOR and LVT techniques can efficiently create memories with multiple ports. Although at the cost of using more memory space. Depending on the application, these memories may be the best option from the many available when creating a multi-port memory.

%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{paper}


%%
%% If your work has an appendix, this is the place to put it.
%\appendix

\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
